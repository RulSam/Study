
# # L = ['a', 'b', 'c']
#     print(id(a))

# L.append('d')
# print(id(L))

# a = 0
# b = 0
#
# while id(a) == id(b):
#     a += 1
#     b += 1
#
# print(a)


# a = 0
# b = 0
#
# while id(a) == id(b):
#     a -= 1
#     b -= 1
#
# print(a)

#
# Рассмотрим парочку примеров. Если мы сохраняем в две переменные одинаковые малые числа, то эти переменные будут равны в двух смыслах: их значения равны (проверяем через ==), и они ссылаются на одинаковые объекты (проверяем через is).
#
# a = 42
# b = 42
#
# print(a == b)
# # True
#
# print(a is b)
# # True
# Однако, если мы проделаем то же самое, но с числами, превышающими границу, найденную в задании, то результат окажется несколько иным.
#
# c = 123456789
# d = 123456789
#
# print(c == d)
# # True
#
# print(c is d)
# # False
# Как и ожидалось, значения переменных равны (мы же явно это написали!), но сами объекты (и соответственно их id) будут разные.
#
# Как уже упоминалось ранее, эту особенность стоит учитывать при работе со списками. Вы обязательно столкнётесь с ситуацией, когда нужно скопировать один список в другой.
#
# L = ['Hello', 'world']
# M = L
#
# print(M is L)
# # True
# Очевидно, что эти списки будут равны по своим значениям (сравнивая через ==). И при таком присваивании в M скопируется не сам список L, а его идентификатор! Поэтому, изменяя список M, мы увидим неожиданные изменения в списке L.
#
# M.append('!')
#
# print(L)
# # ['Hello', 'world', '!']
# Чтобы избежать такого поворота событий, список нужно копировать.
#
# M = L.copy()
#
# print(M is L)
# # False

# Например, мы хотим хранить в кортеже информацию о торгово-развлекательном центре: его название, адрес и список магазинов. В общем-то такой набор информации остаётся почти всегда неизменным за исключением того, что список магазинов может изменяться — какие-то закрываются, какие-то открываются или же меняют название. По этой причине такой список нельзя хранить в самом кортеже. Однако можно создать список (list) внутри самого кортежа.
#
# shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
#
# shopping_center[-1].append("Uniqlo")
#
# print(shopping_center)
# # ('Галерея', 'Санкт-Петербург', 'Лиговский пр., 30', ['H&M', 'Zara', 'Uniqlo'])
# Как видим, изменение списка внутри кортежа не привело к ошибке, потому что уникальный идентификатор этого списка остался неизменным. Можно убедиться в этом самостоятельно.

# shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
# list_id_before = id(shopping_center[-1])
#
# shopping_center[-1].append("Uniqlo")
# list_id_after = id(shopping_center[-1])
# # print(list_id_before == list_id_after, list_id_before is list_id_after)
# print(id(list_id_before) < id(list_id_after), id(list_id_before) is id(list_id_after))

# Напишите программу, которая на вход принимает текст и выводит количество уникальных символов.
#
# Решение
# text = input("Введите текст:")
# text_ = text.replace(" ", "")
# unique = set(text)
#
# print("Количество уникальных символов: ", len(unique))
# text = "TheZenofPython"
# unique = set("TheZenofPython")
# print(list(unique))


# abons = {"Иванов", "Петров", "Васильев", "Антонов"}
#
# debtors = {"Петров", "Антонов"}
#
# non_debtors = abons.difference(debtors)
#
# print(non_debtors)
# # {'Васильев', 'Иванов'}

# set.union(other)	Объединение	Возвращает множество, состоящее из элементов set и other.
#
# set.intersection(other)	Пересечение	Возвращает множество, состоящее из элементов, которые встречаются и в set, и в other.
#
# set.difference(other)	Разность	Возвращает множество элементов set, которые не встречаются в other.
#
# set.symmetric_difference(other)	Симметричная разность	Возвращает множество элементов, встречающиеся в одном из множеств, но не в обоих одновременно.


# a = input("Введите первую строку: ")
# b = input("Введите вторую строку: ")
#
# a_set, b_set = set(a), set(b) # используем множественное присваивание
#
# a_and_b = a_set.intersectionn(b_set)
#
# print(a_and_b)


# a = input("Введите первую строку: ")
# b = input("Введите вторую строку: ")
#
# a_set, b_set = set(a), set(b) # используем множественное присваивание
#
# a_and_b = a_set.symmetric_difference(b_set)
#
# print(a_and_b)