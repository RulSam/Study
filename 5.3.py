# some_var = (2,)
#
# if some_var is None:
#     print("NoneType")
# else:
#     print(type(some_var))


# a = None # пустая строка
# b = a or 1
# print()

# a = "foo"
# b = "bar"
#
# print(1 and a or b)

# a = ""
# b = "bar"
#
# print(1 and a or b)




# a = int(input())
# b = int(input())
# a = 0
# b = 0

# if a and b:
#     print("Обе переменные истинные")
#     print(a,b)
# elif a or b:
#     print("Одна из переменных истинная")
#     print(a or b) # печать одной переменной, которая является истинной
# else:
#     print("Обе переменные ложные")


# Представим, что на вход нашей программы подаётся число. А мы хотим проверить, является ли оно целым, находится ли в определённом промежутке (например, от 100 до 999 включительно), да ещё и делится ли на 2 и 3 одновременно. Очень много условий. И такое случается в реальных проектах.
#
# Решение в лоб — использовать вложенные условные операторы. Один if внутри другого if и т.д. Наверняка есть способ сделать это быстрее и эффективнее, но для начала попробуем написать решение в таком варианте, чтобы было с чем сравнить:
#
# a = int(input())
#
# Задание 5.3.9
# Задание на самопроверку.
#
# Напишите алгоритм, реализованный с помощью вложенных условных операторов, который проверяет заданные выше условия.
#
# Ответ
# if type(a) == int:
#     if 100 <= a <= 999:
#         if a % 2 == 0:
#             if a % 3 == 0:
#                 print("Число удовлетворяет условиям")


# Генераторы списков — это специальный синтаксис, определяющий правила создания и заполнения списков.
# В общем виде эта конструкция записывается следующим образом:
#
# L = [ a for a in some_iter_obj if cond ]
# Такая запись аналогична следующей:
#
# L = []
#
# for a in some_iter_obj:
#     if cond:
#         L.append(a)


# Рассмотрим несколько примеров.
#
# Напишем генератор списков, в котором будут храниться квадраты первых 10 натуральных чисел.
#
# squares = [i**2 for i in range(1,11)]
# # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
# Можно модифицировать этот генератор списков таким образом, что в список будут включаться квадраты только от нечётных чисел.
#
# squares = [i**2 for i in range(1,11) if i % 2 == 1]
# # [1, 9, 25, 49, 81]
# Тип элемента, который будет включаться в список, может быть любым. Например, можно составить список из кортежей:
#
# list_tuples = [(i, i**2) for i in range(1,11)]
# #[(1, 1),
# # (2, 4),
# # (3, 9),
# # (4, 16),
# # (5, 25),
# # (6, 36),
# # (7, 49),
# # (8, 64),
# # (9, 81),
# # (10, 100)]
# А используя вложенные генераторы списков, можно создать матрицу «одним махом»:
#
# M = [[i+j for j in range(5)] for i in range(5)]
# #[[0, 1, 2, 3, 4],
# # [1, 2, 3, 4, 5],
# # [2, 3, 4, 5, 6],
# # [3, 4, 5, 6, 7],
# # [4, 5, 6, 7, 8]]
# В данном случае мы на каждой итерации цикла с индексом i создавали вложенный список с индексами j, что в итоге позволило создать матрицу (таблицу чисел).


# При помощи генератора списков создайте таблицу умножения чисел от 1 до 10.
#
# Ответ
# T = [[i*j for j in range(1,11)] for i in range(1,11)]
# Интересный эффект образуется в сочетании использования генераторов списков и функции input(). На каждой итерации цикла консоль будет запрашивать данные для ввода и сохранять их в качестве элемента списка.
#
# L = [input() for i in range(5)]
# Приведённый выше пример 5 раз запросит у пользователя данные для входа и запишет их в список. Здесь же можно использовать сразу преобразование в необходимый тип, если он заранее известен.
#
# L = [int(input()) for i in range(5)]
# Задание 5.3.14
# Задание на самопроверку.
#
# Модифицируйте последний пример таким образом, чтобы в список сохранялось True, если элемент чётный, и False, если элемент нечётный.
#
# Ответ
# L = [int(input()) % 2 == 0 for i in range(5)]
# print(any(L))
#
# Рассмотрим ещё одну полезную «фичу», которая упрощает работу со списками в циклах (а значит, и во вложенных генераторах).
#
# Допустим, у нас есть два списка одинакового размера:
#
# L = [i for i in range(10)]
# # 0 1 2 3 4 5 6 7 8 9
# M = [i for i in range(10,0,-1)]
# # 10 9 8 7 6 5 4 3 2 1
# И нам необходимо создать новый список, который будет состоять из произведений соответствующих элементов друг на друга.
#
# # он должен выглядеть так
# # 0 9 16 21 24 25 24 21 16 9
# Мы знаем, что элементов в списке 10, поэтому можем пробежаться в цикле по индексам от 0 до 10:
#
# N = [ ]
#
# for i in range(10):
#     N.append(L[i] * M[i])
# Такой код является корректным, но не «питоновским». Мы знаем, что циклом for можно итерировать сразу списки.
#
# Например:
#
# for a in L:
#     # какой-то код
# Но хотелось бы сделать так же, только сразу по двум спискам. В Python существует функция zip(), позволяющая объединить два списка в новый список кортежей, каждый из которых будет содержать по одному элементу из каждого списка.
#
# for a in zip(L,M):
#     print(a)
# #(0, 10)
# #(1, 9)
# #(2, 8)
# #(3, 7)
# #(4, 6)
# #(5, 5)
# #(6, 4)
# #(7, 3)
# #(8, 2)
# #(9, 1)
# Код можно сделать ещё более приятным:
#
# for a, b in zip(L,M):
#     print('a =', a, 'b =', b)
# #a = 0 b = 10
# #a = 1 b = 9
# #a = 2 b = 8
# #a = 3 b = 7
# #a = 4 b = 6
# #a = 5 b = 5
# #a = 6 b = 4
# #a = 7 b = 3
# #a = 8 b = 2
# #a = 9 b = 1


# Задание 5.3.17
# Задание на самопроверку.
#
# Используя функцию zip() внутри генераторов списков, вычислите поэлементные произведения списков L и M.
#
# Ответ
# N = [a*b for a,b in zip(L,M)]


# Задание
# 5.3
# .18
# Задание
# на
# самопроверку.
#
# Реализуйте
# программу, которая
# сжимает
# последовательность
# символов.На
# вход
# подаётся
# последовательность
# вида:
#
# aaabbccccdaa
# Необходимо
# вывести
# строку, где
# каждая
# последовательность
# из
# одинаковых
# символов, идущих
# подряд, заменяется
# на
# один
# символ, и
# длину
# этой
# последовательности(включая
# последовательности
# единичной
# длины).Вывод
# должен
# выглядеть
# так:
#
# a3b2c4d1a2
# Ответ
# text = input()  # получаем строку
#
# last = text[0]  # сохраняем первый символ
# count = 0  # заводим счётчик
# result = ''  # и результирующую строку
#
# for c in text:
#     if c == last:  # если символ совпадает с сохранённым,
#         count += 1  # то увеличиваем счётчик
#     else:
#         result += last + str(count)  # иначе записываем в результат
#         last = c  # и обновляем сохранённый символ с его счётчиком
#         count = 1
#
# result += last + str(count)  # и добавляем в результат последний символ
# print(result)