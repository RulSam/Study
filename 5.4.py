# В этом юните вы встретите термин «операции распаковки». Давайте сразу разберемся, что это такое.
#
# Под операцией распаковки подразумеваются префиксные операторы * и **, которые используются перед переменными.
# Их можно применять, например, для распаковки элементов списка:
#
# numbers = [2, 1, 3, 4, 7]
# more_numbers = [*numbers, 11, 18]
# print(*more_numbers, sep=', ')
# 2, 1, 3, 4, 7, 11, 18
# Оператор * используется:


# Оператор * используется:
#
# для передачи аргументов в функцию;
# для сбора переданных в функцию аргументов;
# при распаковке кортежей;
# для распаковки итерируемых объектов в список/кортеж.
# При вызове функции можно использовать оператор * для распаковки итерируемого объекта в аргументы функции (на примере (print)):
#
# fruits = ['lemon', 'pear', 'watermelon', 'tomato']
#
# print(fruits[0], fruits[1], fruits[2], fruits[3])
# lemon pear watermelon tomato
# print(*fruits)
# lemon pear watermelon tomato


# Оператор ** используется для распаковки словарей.




# ____________________________________________________________
# Простые функции
# О функциях мы очень многое узнали в предыдущем модуле, поэтому перейдём к практическим задачам.
#
# Для начала напишем простую функцию, которая будет решать обычное линейное уравнение:
#
# # a*x = b
# # x = b/a

# def linear_solve(a, b):
#     return b / a
# print(linear_solve(2, 9))




# def linear_solve(a, b):
#  return b / a
# print(linear_solve(0,1))

# Оказывается, наша функция может решать не все уравнения. Хотя оно казалось простым.
#
# Модифицируем её код, чтобы она могла учитывать такое поведение.

# def linear_solve(a, b):
#     if a:  # помним, что 0 интерпретируется как False, иначе True
#         return b / a
#     else:
#         return "Нет корней"
#
#
#
# print(linear_solve(0, 1))



# def linear_solve(a, b):
#     if a:
#         return b / a
#     elif not a and not b: # снова используем числа в логических выражениях
#         return "Бесконечное количество корней"
#     else:
#         return "Нет корней"


# Усложним задачу и реализуем функцию, решающую квадратные уравнения. Вспомним сначала матчасть:

# a*x**2 + b*x + c = 0 - общий вид уравнения
# D = b**2 - 4*a*c - дискриминант
# Если D<0, то уравнение не имеет вещественных корней
# Если D=0, то уравнение имеет один корень - x = -b/(2*a)
# Если D>0, то уравнение имеет два корня
# x1 = (-b - D**0.5)/(2*a)
# x2 = (-b + D**0.5)/(2*a)
#
# P.S. D**0.5 - равносильно извлечению квадратного корня
# Пойдём поэтапно. Сначала напишем функцию, вычисляющую дискриминант уравнения.
#
# Задание 5.4.3
# Задание на самопроверку.
#
# Напишите функцию D(a, b, c), возвращающую дискриминант квадратного уравнения.
#
# Ответ
# def D(a, b, c):
#     return b ** 2 - 4 * a * c
# Следующим этапом реализуем функцию, возвращающую «Нет вещественных корней», если дискриминант отрицательный.
#
# Задание 5.4.4
# Задание на самопроверку.
#
# Реализуйте функцию quadratic_solve(a, b, c), возвращающую «Нет вещественных корней» в случае отрицательного дискриминанта.
#
# Ответ
# def quadratic_solve(a, b, c):
#     if D(a, b, c) < 0:
#         return "Нет вещественных корней"
# Далее модифицируем функцию таким образом, чтобы при нулевом дискриминанте возвращалось значение единственного корня.
#
# Задание 5.4.5
# Задание на самопроверку.
#
# Модифицируйте функцию quadratic_solve(a, b, c), чтобы она возвращала единственный корень при условии нулевого дискриминанта.
#
# Ответ
# def quadratic_solve(a, b, c):
#     if D(a, b, c) < 0:
#         return "Нет вещественных корней"
#     elif D(a, b, c) == 0:
#         return -b / (2 * a)
# И последним этапом нам нужно вернуть сразу два значения. Конечный вид функции будет выглядеть так:
#
# def quadratic_solve(a, b, c):
#     if D(a, b, c) < 0:
#         return "Нет вещественных корней"
#     elif D(a, b, c) == 0:
#         return -b / (2 * a)
#     else:
#         return (-b - D(a,b,c) ** 0.5) / (2 * a), (-b + D(a, b, c) ** 0.5) / (2 * a)




# Рекурсия
# Рекурсивные алгоритмы решения некоторых задач являются более эффективными, чем другие. В предыдущем модуле мы рассмотрели несколько примеров использования такого подхода, а сейчас потренируемся с некоторыми базовыми примерами.
#
# Задание 5.4.9
# Задание на самопроверку.
#
# Напишите рекурсивную функцию, находящую минимальный элемент списка без использования циклов и встроенной функции min().
#
# Ответ
# def min_list(L):
#     if len(L) == 1:
#         return L[0]
#     return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])

# Декораторы
# Напоследок займёмся декорацией функций. Как вы наверняка помните, декораторы призваны дополнять поведение функции без изменений в самой функции. Можно считать время, затраченное на выполнение функции, или выводить служебную информацию о ней. Со временем мы познакомимся с несколькими удобными использованиями декораторов, а сейчас рассмотрим только один, который предвосхищает декоратор проверки авторизации пользователя из встроенных средств Django.
#
# Пусть у нас есть функция, которая должна извлекать из базы данных какую-то информацию. На начальном этапе разработки мы не заботились о том, что это можно делать только при условии, что пользователь программы авторизовался, но сейчас время пришло. Попробуем написать декоратор, который позволяет вызвать функцию, только если она вызывается авторизованным пользователем.
#
# yesno = input("""Введите Y, если хотите авторизоваться, или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
#
# def is_auth(func):
#     def wrapper():
#         if auth:
#             print("Пользователь авторизован")
#             func()
#         else:
#             print("Пользователь не авторизован. Функция выполнена не будет")
#     return wrapper
#
#
# @is_auth
# def from_db():
#     print("some data from database")
#
#
# from_db()
#
#
# USERS = ['admin', 'guest', 'director', 'root', 'superstar']
#
# yesno = input("""Введите Y, если хотите авторизоваться, или N,
#              если хотите продолжить работу как анонимный пользователь: """)
#
# auth = yesno == "Y"
#
# if auth:
#     username = input("Введите ваш username:")
#
# @is_auth
# @has_access
# def from_db():
#     print("some data from database")
#
# from_db()
#
# def has_access(func):
#     def wrapper():
#         if username in USERS:
#             print("Авторизован как", username)
#             func()
#         else:
#             print("Доступ пользователю", username, "запрещён")
#     return wrapper