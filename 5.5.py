# map
# Функция map пришла из функционального программирования. Она позволяет применять некую функцию к каждому элементу итерируемого объекта (строки, списки, кортежи, словари).
#
# Вот псевдокод, по которому работает map. Псевдокод — компактный, зачастую неформальный, способ описания алгоритмов, использующий ключевые слова языков программирования, но опускающий несущественные для понимания алгоритма подробности и специфический синтаксис.
#
# def map_(func, some_list):
#     # some_list объект, над которым будет производиться преобразование
#     # func функция, которая должна выполняться над каждым объектом
#     outp = []
#     for i in range(len(some_list)):
#         outp.append(func(some_list[i]))
#     return outp
# Чтобы не использовать такую конструкцию каждый раз, введена встроенная функция:
#
# map(function, iter1, iter2, ...)
# iter1, iter2, ... — может быть 1 и более итерируемых объектов, однако на вход функции должно приходить такое же количество аргументов.
# function — ссылка на функцию.
#
# Но особенность функции map в том, что она возвращает результат вычислений не сразу, а в виде итератора, который в дальнейшем производит «ленивые» вычисления. Чтобы получить список значений, нужно в явном виде привести к нужному типу либо воспользоваться циклом for:
#
# print(list(map(pow_, a_list)))  # [1, 4, 9]
#
# for i in map(pow_, a_list):
#    pass
# Задание 5.5.1
# Задание на самопроверку.
#
# С помощью метода строки str.lower перевести все элементы списка в нижний регистр.
#
# L = ['THIS', 'IS', 'LOWER', 'STRING']
# Ответ
# print(list(map(str.lower, L)))
# # ['this', 'is', 'lower', 'string']


# Задание 5.5.2
# Задание на самопроверку.
#
# Отфильтровать из заданного списка только чётные элементы.
# def even_numbers(x):
#     return x % 2 == 0
# result = filter(even_numbers, [-2, -1, 0, 1, -3, 2, -3])
# print(list(result))


#
# В каких случаях стоит использовать map и filter?
# Чаще всего генераторы списков более читаемы, чем map и filter, особенно в простых конструкциях.
#
# # map + filter
# some_list = [i - 10 for i in range(20)]
# def pow2(x): return x**2
# def positive(x): return x > 0
#
# print(some_list)
# print(list(map(pow2, filter(positive, some_list))))
# То же самое через list comprehension.
#
# [i**2 for i in some_list if i > 0]
# Возникает вопрос, когда использовать map, а когда list comprehension? Как оговаривалось ранее, map работает по принципу ленивых вычислений, а list comprehension возвращает результат вычислений сразу.
#
# map(func, list1)  # итератор, но никаких вычислений не будет произведено
# list(map(...))  # только здесь появляется объект
#
# [func(i) for i in list1]  # сразу готовый объект
#
#
# [func(i) for i in list1] == list(map(func, list1))  # результат один и тот же